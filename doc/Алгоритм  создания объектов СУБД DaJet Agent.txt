Код ниже выполняется каждый раз, когда запускается сеанс выгрузки данных из
исходящей очереди (регистра сведений) 1С. Сеанс запускается тогда, когда
не было сообщений для обработки и сервис простаивал установленное в настройках время.

Если есть сообщения для обработки сервис работает до тех пор, пока все сообщения
не будут обработаны. Теоретически это может продолжаться бесконечно.

Код ниже нужен для самовосстановления объектов СУБД, необходимых
для корректной работы сервиса. Объекты СУБД могут быть удалены или
не соответствовать текущей версии регистра сведений (исходящей очереди).
Таким образом сервис поддерживает 4 (четыре) возможные версии регистра сведений.
Так сложилось исторически ¯\_(ツ)_/¯

Определение текущей версии регистра выполняется также в начале запуска сеанса обмена.
Это достигается путём чтения метаданных 1С и сравнения с четырьмя известными структурами регистра.
В случае невозможности определить версию регистра сведений выдаётся критическая ошибка:
"Интерфейс данных исходящей очереди не поддерживается."

*****************************************************
* 1. Проверка на наличие необходимых объектов СУБД. *
*****************************************************

SELECT 1 FROM sys.sequences WHERE name = 'DaJetOutgoingQueueSequence';

SELECT 1 FROM sys.triggers WHERE name = '{TRIGGER_NAME}';

*************************************************************************
* Самовосстановление объектов СУБД если проверка выше прошла неуспешно. *
* Всё это нижеописанное выполняется в одной транзакции СУБД.            *
*************************************************************************

******************************************************************
* 1. Удаляем триггер на исходящей очереди 1С (регистр сведений). *
******************************************************************

SELECT t.name AS [trigger_name]
  FROM sys.triggers AS t
 INNER JOIN sys.trigger_events AS e ON t.object_id = e.object_id
 WHERE t.is_instead_of_trigger = 1
   AND e.type = 1
   AND t.parent_id = OBJECT_ID('{TABLE_NAME}', 'U');

IF OBJECT_ID('{TRIGGER_NAME}', 'TR') IS NOT NULL BEGIN DROP TRIGGER {TRIGGER_NAME} END;

******************************************************
* 2. Восстанавливаем объект последовательности СУБД. *
******************************************************

IF NOT EXISTS(SELECT 1 FROM sys.sequences WHERE name = 'DaJetOutgoingQueueSequence')
BEGIN
   CREATE SEQUENCE DaJetOutgoingQueueSequence AS numeric(19,0) START WITH 1 INCREMENT BY 1;
END;

************************************************************************************************
* 3. Выполняем перенумерацию существующих сообщений с использованием новой последовательности. *
************************************************************************************************

SELECT {МоментВремени} AS [МоментВремени], {Идентификатор} AS [Идентификатор],
NEXT VALUE FOR DaJetOutgoingQueueSequence OVER(ORDER BY {МоментВремени} ASC, {Идентификатор} ASC) AS [НомерСообщения]
INTO #{TABLE_NAME}_EnumCopy
FROM {TABLE_NAME} WITH (TABLOCKX, HOLDLOCK);
UPDATE T SET T.{МоментВремени} = C.[НомерСообщения] FROM {TABLE_NAME} AS T
INNER JOIN #{TABLE_NAME}_EnumCopy AS C ON T.{МоментВремени} = C.[МоментВремени] AND T.{Идентификатор} = C.[Идентификатор];

*****************************************************************************************
* 4. Удаляем вспомогательную для перенумерации из предыдущего пункта временную таблицу. *
*****************************************************************************************

DROP TABLE #{TABLE_NAME}_EnumCopy;

***************************************************************************
* 5. На всякий случай удаляем старую версию триггера, если он существует. *
***************************************************************************

IF OBJECT_ID('{TRIGGER_NAME}', 'TR') IS NOT NULL BEGIN DROP TRIGGER {TRIGGER_NAME} END;

*************************************************************
* 6. Создаём триггер, использующий последовательность СУБД. *
*************************************************************

CREATE TRIGGER {TRIGGER_NAME} ON {TABLE_NAME} INSTEAD OF INSERT NOT FOR REPLICATION AS
INSERT {TABLE_NAME}
({МоментВремени}, {Идентификатор}, {Заголовки}, {Отправитель}, {Получатели},
{ТипСообщения}, {ТелоСообщения}, {ДатаВремя}, {Ссылка}, {ТипОперации})
SELECT NEXT VALUE FOR DaJetOutgoingQueueSequence,
i.{Идентификатор}, i.{Заголовки}, i.{Отправитель}, i.{Получатели},
i.{ТипСообщения}, i.{ТелоСообщения}, i.{ДатаВремя}, i.{Ссылка}, i.{ТипОперации}
FROM inserted AS i;

******************************************************************************
* 7. Включаем триггер: транзакция завершается. Самовосстановление завершено. *
******************************************************************************

ENABLE TRIGGER {TRIGGER_NAME} ON {TABLE_NAME};